@[toc]
# jvm
## jvm内存模型
<center>
<img src="https://img-blog.csdnimg.cn/20200413080513982.png" width="80%">

### 方法区（线程共享）
常量，静态变量以及JIT编译后的代码都在方法区。主要存储已被虚拟机加载的类信息。也可以称为“永久代”，垃圾回收效果一般，通过-XX：MaxPermSize控制上限。
JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是**元空间，元空间使用的是直接内存。**
#### 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?
整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。

### 堆内存（线程共享）
**堆内存是垃圾回收的主要场所，也是线程之间共享的区域，主要用来存储创建的对象实例**，通过-Xmx 和-Xms 可以控制大小。

### 虚拟机栈（栈内存）
栈内存中主要保存**局部变量、基本数据类型变量以及堆内存中某个对象的引用变量。**每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表，操作数栈，动态链接，方法出口等信息。栈中的栈帧随着方法的进入和退出有条不紊的执行着出栈和入栈的操作。
### 程序计数器
程序计数器是**当前线程执行的字节码的位置指示器**。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，**是内存区域中唯一一个在虚拟机规范中没有规定任何OutOfMemoryError情况的区域。**
### 本地方法栈：
主要是为JVM提供使用native 方法的服务。

#### 程序计数器为什么是私有的?
程序计数器主要有下面两个作用：
1.	字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2.	在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。
所以，**程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。**
#### 虚拟机栈和本地方法栈为什么是私有的?
•	虚拟机栈： 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
•	本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。
所以**为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。**
#### 一句话简单了解堆和方法区
堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

## 可以说一下对象创建过程中的内存分配吗？
**New创建对象-----jvm判断定位、是否完成类加载--------没有就执行类加载-------从堆中进行内存分配**
1、通过new指令来创建对象，
2、当虚拟机遇到一条new指令的时候，会去检查这个指令的参数是否能在常量池中定位到某个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。如果没有，那么会执行类加载过程。
3、通过执行类的加载，验证，准备，解析，初始化步骤，完成了类的加载，
4、这个时候会为该对象进行内存分配，也就是把一块确定大小的内存从Java堆中划分出来，在分配的内存上完成对象的创建工作。
### 对象的内存分配有两种方式，即指针碰撞和空闲列表方式。
#### 指针碰撞
自己的话：Java堆内存绝对规整，一边用过，一边没用，中间有个指针，内存分配指针挪动。
假设Java堆中的内存是绝对规整的，用过的内存在一边，未使用的内存在另一边，中间有一个指示指针，那么所有的内存分配就是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。
#### 空闲列表
自己的话：Java堆内存不规整，用过的和未用过的交错，jvm维护一个列表记录哪个内存可用，分配后更新。 
如果Java堆内存中不是规整的，已使用和未使用的内存相互交错，那么虚拟机就必须维护一个列表用来记录哪块内存是可用的，在分配的时候找到一块足够大的空间分配对象实例，并且需要更新列表上的记录。
需要注意的是，Java 堆内存是否规整是由所使用的垃圾收集器是否拥有压缩整理功能来决定的，

## 对象被访问的时候是怎么被找到的？（访问对象）
当创建一个对象的时候，在栈内存中会有一个引用变量，指向堆内存中的某个具体的对象实例。
Java虚拟机规范中并没有规定这个引用变量应该以何种方式去定位和访问堆内存中的具体对象。目前常见的对象访问方式有两种，即句柄访问方式和直接指针访问方式，分别介绍如下。
### 句柄访问方式：
在JVM的堆内存中划分出一块内存来作为句柄池，引用变量中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息。在内存垃圾收集之后，对象会移动，但是引用reference中存储的是稳定的句柄地址，但是句柄地址方式不直接，访问速度较慢。
### 直接指针访问方式：
引用变量中存储的就是对象的直接地址，通过指针直接访问对象。直接指针的访问方式节省了一次指针定位的时间开销，速度较快。Sun HotSpot使用了直接指针方式进行对象的访问。
### Java中new一个对象是一个怎样的过程？JVM中发生了什么？	
[链接](https://www.cnblogs.com/gjmhome/p/11401397.html)
https://blog.csdn.net/Rainnnbow/article/details/52149586
1、类加载
2、分配内存空间
3、设置对象基本信息
4、程序员意愿的初始化与调用构造函数

## 垃圾回收

### 判断对象是否可回收？
主要是看其有没有引用，判断对象是否存在引用关系的方法主要有：引用计数法、root搜索法
#### 引用计数法：
是一种比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只需要收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。
#### root根搜索方法：
root搜索方法的基本思路就是通过一系列可以做为root的对象作为起始点，从这些节点开始向下搜索。当一个对象到root节点没有任何引用链接时，则证明此对象是可以被回收的。以下对象会被认为是root对象：
•	栈内存中引用的对象
•	方法区中静态引用和常量引用指向的对象
•	被启动类（bootstrap加载器）加载的类和创建的对象
•	Native方法中JNI引用的对象。
总结就是，**方法运行时，方法中引用的对象；类的静态变量引用的对象；类中常量引用的对象；Native方法中引用的对象。**
## 对象的引用
如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称为这块内存代表一个引用。JDK1.2以后将引用分为强引用，软引用，弱引用和虚引用四种。
•	强引用：普通存在， P p = new P()，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。
•	软引用：通过SoftReference类来实现软引用，在内存不足的时候会将这些软引用回收掉。
•	弱引用：通过WeakReference类来实现弱引用，每次垃圾回收的时候肯定会回收掉弱引用。
•	虚引用：也称为幽灵引用或者幻影引用，通过PhantomReference类实现。设置虚引用只是为了对象被回收时候收到一个系统通知。

## 垃圾回收算法、优缺点、场景
Hotspot虚拟机采用了root根搜索方法进行内存回收，**常用的回收算法：标记清除算法、复制算法、标记整理算法。垃圾回收算法是垃圾收集器的算法实现基础，年轻代垃圾回收一般采用复制算法，老年代垃圾回收一般采用标记-清除和标记-整理算法。**
#### 1.	标记清除算法
分两个阶段：第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。**此算法需要暂停整个应用，并且会产生内存碎片。**
![在这里插入图片描述](https://img-blog.csdnimg.cn/2020042113584647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L293ZW5meQ==,size_16,color_FFFFFF,t_70)

#### 2.	复制算法
复制算法把内存划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用的对象复制到另外的一个区域中。复制算法每次只处理正在使用的对象，因此复制成本比较低，同时复制过去以后还能进行相应的内存整理，不会出现碎片问题。**当然缺点很明显，需要两倍内存。**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200421135913810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L293ZW5meQ==,size_16,color_FFFFFF,t_70)
#### 3.	标记-整理算法
结合前面两个的优点。分两个阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，清除未标记的对象并把存活对象压缩到堆的其中一块，按顺序排放。**此算法避免了“标记-清除”的碎片问题，同时避免了复制算法的空间问题。**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200421135953695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L293ZW5meQ==,size_16,color_FFFFFF,t_70)

### 分代垃圾回收
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200421114755972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L293ZW5meQ==,size_16,color_FFFFFF,t_70)
#### Minor GC（年轻代GC）:
对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次Minor GC，因为Java大多数对象都是朝生夕灭，所以Minor GC非常频繁，而且速度也很快。
#### Full GC（老年代GC）:
Full GC是指发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，发生Full GC一般都会有一次Minor GC。

**年轻代垃圾回收一般采用复制算法（新生代对象的存活率比较低），老年代垃圾回收一般采用标记-清除和标记-整理算法。（老年代存活率比较高）**

https://blog.csdn.net/hp910315/article/details/50985877?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task
（这个链接有图的过程）

1.	新创建的对象一般放在新生代的Eden区
2.	当Eden被使用完就会发生Minor GC
- 首先把存活对象复制到Survivor1中，设置对象年龄为1
- 把Eden清空，这样第一次GC就完成了。
3.	当Eden再一次被使用完时，就会再次进行GC操作
- 	跟上面一样，将Enden区和Survivor1中的存活对象复制到Survivor2中。清空
- 	Enden中复制到Survivor2中的对象年龄设置为1，将Survivor1中复制到Survivor2中的对象年龄加1
3)	新生代第二次GC就完成了。当Enden再一次被使用完的时候，就会发生第三次GC操作了就是重复了
4.	那什么时候进入老年代？如果对象在GC过程中没有被回收，那么它的对象年龄（Age）会不断的增加，对象在Survivor区每熬过一个Minor GC，年龄就增加1岁，当它的年龄到达一定的程度（默认为15岁），就会被移动到老年代，这个年龄阀值可以通过-XX:MaxTenuringThreshold设置。
### 为什么需要survivor,为什么需要两个
Survivor 的存在意义就是**减少被送到老年代的对象**，进而减少 Major GC 的发生。Survivor 的预筛选保证，只有经历16次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。
因为第一次gc后，s1和eden都存在垃圾，需要把存活的对象移到s2,。
### Stop The World
Java中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）
### 频繁full gc
可能jvm参数设置不合理、


### 垃圾收集器
#### 提问形式
JVM CMS垃圾回收器和G1之间的区别？G1详细是怎么回收垃圾的？
#### CMS(Concurrent Mark Sweep)收集器  (英文来记)
CMS收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于**标记-清除算法**实现的，是一种**老年代收集器**，通常与ParNew一起使用
CMS的垃圾收集过程分为4步：(两次 stop the world)
•	初始标记：需要“Stop the World”，初始标记仅仅只是标记一下GC Root能直接关联到的对象，速度很快。
•	并发标记：是主要标记过程，这个标记过程是和用户线程并发执行的。
•	重新标记：需要“Stop the World”，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（停顿时间比初始标记长，但比并发标记短得多）。
•	并发清除：和用户线程并发执行的，基于标记结果来清理对象。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200421140429421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L293ZW5meQ==,size_16,color_FFFFFF,t_70)
##### CMS垃圾回收器的优缺点分析：
CMS以降低垃圾回收的停顿时间为目的，很显然其具有**并发收集，停顿时间低的优点**。
缺点主要包括如下：
•	**对CPU资源非常敏感**，因为并发标记和并发清理阶段和用户线程一起运行，当CPU数变小时，性能容易出现问题。
•	**收集过程中会产生浮动垃圾，所以不可以在老年代内存不够用了才进行垃圾回收，必须提前进行垃圾收集**。通过参数-XX:CMSInitiatingOccupancyFraction的值来控制内存使用百分比。如果该值设置的太高，那么在CMS运行期间预留的内存可能无法满足程序所需，会出现Concurrent Mode Failure失败，之后会临时使用Serial Old收集器做为老年代收集器，会产生更长时间的停顿。
•	**标记-清除方式会产生内存碎片**，可以使用参数-XX：UseCMSCompactAtFullCollection来控制是否开启内存整理（无法并发，默认是开启的）。参数-XX:CMSFullGCsBeforeCompaction用于设置执行多少次不压缩的Full GC后进行一次带压缩的内存碎片整理（默认值是0）。

#### G1（Garbage-First）收集器：
G1收集器将新生代和老年代取消了，取而代之的是将堆划分为若干的区域，仍然属于分代收集器，区域的一部分包含新生代，**新生代采用复制算法，老年代采用标记-整理算法**。
通过将JVM堆分为一个个的区域（region）,G1收集器可以避免在Java堆中进行全区域的垃圾收集。G1跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据回收时间来优先回收价值最大的region。
##### G1收集器的特点：
•	并行与并发：G1能充分利用多CPU，多核环境下的硬件优势，来缩短Stop the World，是并发的收集器。
•	分代收集：G1不需要其他收集器就能独立管理整个GC堆，能够采用不同的方式去处理新建对象、存活一段时间的对象和熬过多次GC的对象。
•	空间整合：G1从整体来看是基于标记-整理算法，从局部（两个Region）上看基于复制算法实现，G1运作期间不会产生内存空间碎片。
•	可预测的停顿：能够建立可以预测的停顿时间模型，预测停顿时间。
##### 和CMS收集器类似，G1收集器的垃圾回收工作也分为了四个阶段：
•	初始标记
•	并发标记
•	最终标记     （cms：重新标记）
•	筛选回收      （并发清除）

## 类加载器
### 类加载机制
Java中的类加载机制指虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换、解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。
类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括了：**加载、验证、准备、解析、初始化、使用、卸载七个阶段。类加载机制的保持则包括前面五个阶段**。
•	加载：
加载是指将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。
•	验证：
验证的作用是确保被加载的类的正确性，包括文件格式验证，元数据验证，字节码验证以及符号引用验证。
•	准备：
准备阶段为类的静态变量分配内存，并将其初始化为默认值。假设一个类变量的定义为public static int val = 3;那么变量val在准备阶段过后的初始值不是3而是0。
•	解析：
解析阶段将类中符号引用转换为直接引用。符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。
•	初始化：
初始化阶段为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。
### 类加载器分类
•	启动类加载器（Bootstrap ClassLoader）：
启动类加载器负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的类。
•	扩展类加载器（ExtClassLoader）：
扩展类加载器负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类）。
•	应用类加载器（AppClassLoader）：
应用类加载器负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器。
### 类加载器的职责：
•	全盘负责：
当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显式使用另外一个类加载器来载入。
### 双亲委派
**如果一个类加载器（ClassLoader）收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成**，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，**只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需要加载的类）时，子加载器才会尝试自己去加载。**
#### 使用双亲委托机制的好处是：
　　能够有效确保一个类的全局唯一性，当程序中出现多个限定名相同的类时，类加载器在执行加载时，始终只会加载其中的某一个类

## Jvm调优
### 常用的内存调优命令
- Jps：主要用来输出jvm运行进程状态信息，包括jvm启动参数等
- Jinfo: 主要用来观察进程运行环境参数等信息
- Jstack：查看某个java进程内的线程堆栈信息，jstack pid可以看到当前进程中各个线程的状态信息，包括其持有的锁和等待的锁
- Jmap：查看堆内存使用情况。Jmap -heap pid可以看到当前进程的堆信息和使用的GC收集器，包括年轻代和老年代的大小分配等。
- Jstat：进行实时的命令行监控，包括堆信息以及实时GC信息等，可以使用jstat -gcutil pid 1000每隔一秒来查看当前GC信息。
### 如何排查一个线上的服务异常？
•	首先查看当前进程的JVM启动参数，查看内存设置是否存在明显问题。
•	查看GC日志，看GC频率和时间是否明显异常。
•	查看当前进程的状态信息top -Hp pid，包括线程个数等信息。
•	jstack pid查看当前的线程状态，是否存在死锁等关键信息。
•	jstat -gcutil pid查看当前进程的GC情况。
•	jmap -heap pid查看当前进程的堆信息，包括使用的垃圾收集器等信息。
•	用jvisiual工具打开dump二进制文件，分析是什么对象导致了内存泄漏，定位到代码处，进行code review。
一般情况下，我们在测试环境上线新服务的时候，应该重点关注并且查看当前新服务的内存使用以及回收情况，避免新服务种出现内存异常导致服务崩溃的现象发生。
### JDK8中在内存管理上的变化：
答： JDK8中出现了元空间代替了永久代。元空间和永久代类似，都是对JVM规范中方法区的实现。区别在于元空间并不在虚拟机中，而是使用本地内存，默认情况下元空间的大小仅受本地内存限制，也可以通过-XX：MetaspaceSize指定元空间大小。
### 为什么要使用元空间代替永久代？
字符串在永久代中，容易出现性能问题和内存溢出的问题。类和方法的信息等比较难确定大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出。使用元空间则使用了本地内存。


JAVA_OPTS="
-Xms4096m jvm初始分配的堆内存
–Xmx4096m jvm最大允许分配的堆内存，按需分配
-XX:NewRatio=2 
-XX:SurvivorRatio=8 设置年轻代中Eden区与Survivor区的比值，设置为8，则表示年轻代中Eden区与一块Survivor的比例为8：1。注意年轻代中有两块Survivor区域。
-Xloggc:/home/work/log/serviceName/gc.log 
-XX:+PrintGCDetails 
-XX:+PrintGCTimeStamps 
-XX:+PrintGCApplicationStoppedTime 
-XX:+UseConcMarkSweepGC 
-XX:+UseParNewGC 使用该收集器
-XX:CMSInitiatingOccupancyFraction=75 收集过程中会产生浮动垃圾，所以不可以在老年代内存不够用了才进行垃圾回收，必须提前进行垃圾收集。控制内存使用百分比。如果该值设置的太高，那么在CMS运行期间预留的内存可能无法满足程序所需，会出现Concurrent Mode Failure失败，之后会临时使用Serial Old收集器做为老年代收集器，会产生更长时间的停顿。
-XX:+UseCMSCompactAtFullCollection 来控制是否开启内存整理（无法并发，默认是开启的
-XX:CMSFullGCsBeforeCompaction=10 " 用于设置执行多少次不压缩的Full GC后进行一次带压缩的内存碎片整理（默认值是0）。
### Java调试命令。看线程运行状态用什么？看堆栈信息用什么？
Jstack  Jstack pid
